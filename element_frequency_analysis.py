
"""
Element Frequency Analysis from Virtual Library

Analyzes element occurrence frequencies and mean contents from virtual library
of candidate alloys generated by MTWAE framework.

"""

import os
import argparse
import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from utils import ensure_dir


def parse_composition_string(comp_str):
    """
    Parse composition string into element-fraction dictionary.
    
    Args:
        comp_str: String like "Fe72.5B12.2Co9.5Si3.0"
    
    Returns:
        Dict of {element: fraction}
    """
    pattern = r"([A-Z][a-z]?)([\d.]+)"
    matches = re.findall(pattern, str(comp_str))
    
    composition = {}
    for elem, frac in matches:
        composition[elem] = float(frac)
    
    return composition


def compute_element_statistics(df, comp_column, element_list, criteria=None):
    """
    Compute element frequencies and mean contents.
    
    Args:
        df: DataFrame with composition and property columns
        comp_column: Column name containing composition strings
        element_list: List of element symbols to analyze
        criteria: Optional filtering criteria (dict of conditions)
    
    Returns:
        DataFrame with Element, Frequency (%), Mean Content (at%)
    """
    # Parse compositions
    print("  Parsing compositions...")
    comp_dicts = df[comp_column].apply(parse_composition_string)
    
    # Convert to DataFrame
    comp_df = pd.DataFrame([
        {e: comp.get(e, 0.0) for e in element_list}
        for comp in comp_dicts
    ])
    
    # Combine with properties
    full_df = pd.concat([df, comp_df], axis=1)
    
    # Apply criteria
    if criteria:
        print("  Applying filtering criteria...")
        mask = pd.Series(True, index=full_df.index)
        for col, (op, val) in criteria.items():
            if op == '>':
                mask &= full_df[col] > val
            elif op == '<':
                mask &= full_df[col] < val
            elif op == '>=':
                mask &= full_df[col] >= val
            elif op == '<=':
                mask &= full_df[col] <= val
        
        full_df = full_df[mask]
        print(f"  {len(full_df)} compositions satisfy criteria")
    
    # Compute statistics
    stats = []
    for elem in element_list:
        mask = full_df[elem] > 0
        if mask.any():
            frequency = mask.mean() * 100
            mean_content = full_df.loc[mask, elem].mean()
            stats.append((elem, frequency, mean_content))
    
    stats_df = pd.DataFrame(
        stats,
        columns=['Element', 'Frequency (%)', 'Mean Content (at%)']
    ).sort_values('Frequency (%)', ascending=False).reset_index(drop=True)
    
    return stats_df


def plot_element_frequency(stats_df, output_path, criteria_text=''):
    """
    Create element frequency plot.
    
    Args:
        stats_df: DataFrame with Element, Frequency (%), Mean Content (at%)
        output_path: Save path
        criteria_text: Text describing filtering criteria
    """
    fig, ax = plt.subplots(figsize=(21, 8))
    
    # Bar chart
    bar_color = "#4472C4"
    bars = ax.bar(stats_df['Element'], stats_df['Frequency (%)'],
                  color=bar_color, edgecolor='black', linewidth=1, width=0.75)
    
    # Add frequency labels above bars
    for bar, freq in zip(bars, stats_df['Frequency (%)']):
        ax.text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 0.8,
                f"{freq:.1f}", ha='center', va='bottom',
                fontsize=15, fontweight='normal')
    
    # Labels and formatting
    ylabel = f"Element Frequency ({criteria_text}) (%)" if criteria_text else "Element Frequency (%)"
    ax.set_ylabel(ylabel, fontweight='bold', fontsize=17)
    ax.set_xlabel("Element", fontweight='bold', fontsize=27)
    
    plt.xticks(rotation=0, fontsize=26)
    plt.yticks(fontsize=17)
    
    ax.set_ylim(0, stats_df['Frequency (%)'].max() * 1.18)
    ax.grid(axis='y', linestyle='-', alpha=0.2, linewidth=0.5)
    ax.set_axisbelow(True)
    
    # Clean spines
    ax.spines['top'].set_visible(True)
    ax.spines['right'].set_visible(True)
    
    plt.tight_layout(rect=[0, 0, 0.95, 1])
    fig.savefig(output_path, dpi=300, bbox_inches='tight', 
               facecolor='white', edgecolor='none')
    plt.close()
    
    print(f"  Saved: {output_path}")


def main():
    ap = argparse.ArgumentParser(
        description='Element frequency analysis from virtual library')
    
    # Input file
    ap.add_argument('--input', default='Random_7500_table.xlsx',
                   help='Excel/CSV file with candidate compositions')
    ap.add_argument('--comp_column', default='Random_sample_composition',
                   help='Column name containing composition strings')
    
    # Property columns (for filtering)
    ap.add_argument('--bs_column', default='Bs (T)')
    ap.add_argument('--hc_column', default='ln(Hc) (A/m)')
    ap.add_argument('--dc_column', default='Dc (mm)')
    
    # Filtering criteria (Bs>1.70T, ln(Hc)<1.5, Dc>1mm)
    ap.add_argument('--bs_threshold', type=float, default=1.70)
    ap.add_argument('--hc_threshold', type=float, default=1.5)
    ap.add_argument('--dc_threshold', type=float, default=1.0)
    
    # Elements to analyze 
    ap.add_argument('--elements', nargs='+',
                   default=['Fe', 'B', 'Si', 'P', 'C', 'Co', 'Nb', 'Ni', 'Mo',
                           'Zr', 'Ga', 'Al', 'Dy', 'Cu', 'Cr', 'Y', 'Nd', 'Hf',
                           'Ti', 'Tb', 'Ho', 'Ta', 'Er', 'Sn', 'W', 'Tm', 'Gd',
                           'Sm', 'V'],  
                   help='Elements to analyze')
    
    # Output
    ap.add_argument('--outdir', default='element_frequency_results')
    
    args = ap.parse_args()
    
    ensure_dir(args.outdir)
    
    print("="*80)
    print("Element Frequency Analysis from Virtual Library")
    print("="*80)
    
    # Load data
    print(f"\nLoading data from {args.input}...")
    if not os.path.exists(args.input):
        raise FileNotFoundError(f"Input file not found: {args.input}")
    
    if args.input.endswith('.xlsx') or args.input.endswith('.xls'):
        df = pd.read_excel(args.input)
    else:
        df = pd.read_csv(args.input)
    
    print(f"  Loaded {len(df)} compositions")
    
    # Check required columns
    required_cols = [args.comp_column, args.bs_column, args.hc_column, args.dc_column]
    missing = [col for col in required_cols if col not in df.columns]
    if missing:
        raise ValueError(f"Missing columns: {missing}")
    
    # Define filtering criteria
    criteria = {
        args.bs_column: ('>', args.bs_threshold),
        args.hc_column: ('<', args.hc_threshold),
        args.dc_column: ('>', args.dc_threshold)
    }
    
    criteria_text = f"Bs>{args.bs_threshold} T, Dc>{args.dc_threshold} mm, lnHc<{args.hc_threshold} A/m"
    
    # Compute statistics
    print("\nComputing element statistics...")
    stats_df = compute_element_statistics(
        df, args.comp_column, args.elements, criteria
    )
    
    # Print results
    print("\n" + "="*60)
    print("Element Statistics")
    print("="*60)
    pd.set_option('display.max_rows', None)
    pd.set_option('display.float_format', '{:.2f}'.format)
    print(stats_df)
    
    # Save to CSV
    csv_path = os.path.join(args.outdir, 'element_frequency_statistics.csv')
    stats_df.to_csv(csv_path, index=False, float_format='%.2f')
    print(f"\n  Saved statistics to {csv_path}")
    
    # Key findings
    print("\n" + "="*60)
    print("Key Findings (Top 8 Elements)")
    print("="*60)
    for idx, row in stats_df.head(8).iterrows():
        print(f"  {row['Element']:>3}: {row['Frequency (%)']:5.1f}% frequency, "
              f"{row['Mean Content (at%)']:5.2f} at% mean content")
    
    # Generate publication plot
    print("\nGenerating publication-quality plot...")
    plot_path = os.path.join(args.outdir, 'element_frequency_plot.png')
    plot_element_frequency(stats_df, plot_path, criteria_text)
    
    print(f"\n{'='*80}")
    print(f"Element frequency analysis complete!")
    print(f"Results saved to {args.outdir}/")
    print(f"{'='*80}")


if __name__ == '__main__':
    main()